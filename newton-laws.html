<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Newton's Laws of Motion - 3D Interactive Guide</title>
  <style>
    body {
      font-family: 'Arial', sans-serif;
      margin: 0;
      padding: 0;
      background-color: #f4f4f4;
      color: #333;
    }
    .container {
      max-width: 960px;
      margin: 20px auto;
      padding: 20px;
      background-color: #fff;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
    }
    h1,
    h2,
    h3 {
      color: #0056b3;
    }
    p {
      line-height: 1.6;
    }
    .law-section {
      margin-bottom: 40px;
    }
    .simulation-container {
      width: 100%;
      height: 300px;
      border: 1px solid #ccc;
      position: relative;
      overflow: hidden;
      margin-bottom: 15px;
    }
    .simulation-controls {
      margin-top: 10px;
      text-align: center;
    }
    button {
      padding: 10px 20px;
      margin: 5px;
      border: none;
      background-color: #0056b3;
      color: white;
      cursor: pointer;
      border-radius: 5px;
      font-size: 1em;
    }
    button:hover {
      background-color: #003366;
    }
    canvas {
      width: 100% !important;
      height: 100% !important;
      display: block;
    }
    .key-terms {
      margin-top: 20px;
    }
    .key-terms h3 {
      color: #007bff;
    }
    .key-terms ul {
      list-style-type: disc;
      padding-left: 20px;
    }
    .key-terms li {
      margin-bottom: 8px;
      font-size: 1em;
    }
    .important {
      font-weight: bold;
      color: #d43f3f;
    }
    .code-snippet {
      background-color: #eee;
      padding: 10px;
      border-radius: 5px;
      overflow-x: auto;
      font-family: monospace;
    }
    .credits {
      text-align: center;
      margin-top: 40px;
      color: #777;
      font-size: 0.9em;
    }
    @media (max-width: 768px) {
      .container {
        margin: 10px auto;
        padding: 15px;
      }
      h1 {
        font-size: 1.8em;
      }
      h2 {
        font-size: 1.5em;
      }
      h3 {
        font-size: 1.2em;
      }
      p,
      li {
        font-size: 1em;
      }
      button {
        padding: 8px 16px;
        font-size: 0.9em;
      }
      .simulation-container {
        height: 250px;
        margin-bottom: 10px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Newton's Laws of Motion - Interactive 3D Guide</h1>

    <section class="law-section" id="law1">
      <h2>Newton's First Law of Motion: The Law of Inertia</h2>
      <p>
        Newton's First Law, the Law of Inertia, describes an object's resistance to changes in its state of motion.
      </p>
      <blockquote>
        <p>An object at rest stays at rest, and an object in motion stays in motion with the same velocity unless acted upon by a net force.</p>
      </blockquote>
      <p>Essentially:</p>
      <ul>
        <li><strong>Rest:</strong> Stationary objects remain still without external force.</li>
        <li><strong>Motion:</strong> Moving objects continue moving uniformly unless a force changes their motion.</li>
        <li><strong>Inertia:</strong> This resistance to change is inertia, proportional to mass.</li>
      </ul>

      <div class="key-terms">
        <h3>Key Terms for First Law</h3>
        <ul>
          <li><strong>Inertia:</strong> Resistance to changes in motion.</li>
          <li><strong>Force:</strong> Push or pull, measured in Newtons (N).</li>
          <li><strong>Net Force:</strong> Total force, vector sum of all forces.</li>
          <li><strong>Equilibrium:</strong> Zero net force, constant velocity or rest.</li>
        </ul>
      </div>

      <div class="simulation-container" id="simulation1"></div>
      <div class="simulation-controls" id="controls1">
        <button onclick="applyForce1()">Apply Force</button>
        <button onclick="resetSimulation1()">Reset</button>
      </div>
    </section>

    <section class="law-section" id="law2">
      <h2>Newton's Second Law of Motion: The Law of Acceleration (F=ma)</h2>
      <p>
        Newton's Second Law quantifies how force affects motion, relating force, mass, and acceleration.
      </p>
      <div class="code-snippet">
        <code>F = m * a</code>
      </div>
      <p>Where:</p>
      <ul>
        <li><strong>F</strong> = Net Force (N)</li>
        <li><strong>m</strong> = Mass (kg)</li>
        <li><strong>a</strong> = Acceleration (m/s²)</li>
      </ul>
      <p>In essence:</p>
      <ul>
        <li><strong>Acceleration is proportional to Force:</strong> More force, more acceleration.</li>
        <li><strong>Acceleration is inversely proportional to Mass:</strong> More mass, less acceleration for same force.</li>
        <li><strong>Direction:</strong> Acceleration is always in the net force's direction.</li>
      </ul>

      <div class="key-terms">
        <h3>Key Terms for Second Law</h3>
        <ul>
          <li><strong>Acceleration:</strong> Rate of velocity change (m/s²).</li>
          <li><strong>Mass:</strong> Amount of matter, resistance to acceleration (kg).</li>
          <li><strong>Weight:</strong> Gravitational force on mass (N), Weight = m*g.</li>
        </ul>
      </div>

      <div class="simulation-container" id="simulation2"></div>
      <div class="simulation-controls" id="controls2">
        <button onclick="applyForce2(1)">Small Force</button>
        <button onclick="applyForce2(2)">Medium Force</button>
        <button onclick="applyForce2(3)">Large Force</button>
        <button onclick="changeMass2()">Change Mass</button>
        <button onclick="resetSimulation2()">Reset</button>
      </div>
    </section>

    <section class="law-section" id="law3">
      <h2>Newton's Third Law: Action-Reaction & Elastic Collision</h2>
      <p>
        Newton's Third Law explains that forces are always paired and equal but act in opposite directions. This simulation demonstrates a nearly elastic collision, where two spheres collide and bounce off, exchanging momentum and kinetic energy.
      </p>
      <blockquote>
        <p>For every action, there is an equal and opposite reaction.</p>
      </blockquote>
      <p>More precisely:</p>
      <blockquote>
        <p>When object A exerts a force on object B, object B exerts an equal and opposite force on object A.</p>
      </blockquote>
      <p>Key points of action-reaction in collisions:</p>
      <ul>
        <li><strong>Interaction:</strong> Collision is an interaction where objects exert forces on each other.</li>
        <li><strong>Equal Forces:</strong> The force one sphere exerts on the other is equal in magnitude to the force it receives.</li>
        <li><strong>Opposite Directions:</strong> These forces act in opposite directions, causing the spheres to bounce off.</li>
        <li><strong>Momentum Exchange:</strong> In an elastic collision, momentum and kinetic energy are transferred between the objects.</li>
      </ul>
      <p>
        Click "Initiate Collision" to see the spheres collide and bounce off, illustrating action-reaction in an elastic collision.
      </p>

      <div class="key-terms">
        <h3>Key Terms for Third Law</h3>
        <ul>
          <li><strong>Action Force:</strong> Force exerted by one object on another during interaction.</li>
          <li><strong>Reaction Force:</strong> Equal and opposite force exerted back.</li>
          <li><strong>Elastic Collision:</strong> Collision where objects bounce, conserving momentum and kinetic energy.</li>
          <li><strong>Momentum:</strong> Measure of mass in motion.</li>
          <li><strong>Kinetic Energy:</strong> Energy of motion.</li>
        </ul>
      </div>

      <div class="simulation-container" id="simulation3"></div>
      <div class="simulation-controls" id="controls3">
        <button onclick="applyForce3()">Initiate Collision</button>
        <button onclick="resetSimulation3()">Reset</button>
      </div>
    </section>

    <div class="credits">
      <p>Interactive simulations created with HTML, CSS, JavaScript, and Three.js.</p>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // --- Simulation 1: First Law (Inertia) ---
    let scene1, camera1, renderer1, cube1, velocity1 = 0;
    const acceleration1 = 0.005;

    function initScene1() {
      scene1 = new THREE.Scene();
      camera1 = new THREE.PerspectiveCamera(75, simulation1.offsetWidth / simulation1.offsetHeight, 0.1, 1000);
      renderer1 = new THREE.WebGLRenderer({ antialias: true });
      renderer1.setSize(simulation1.offsetWidth, simulation1.offsetHeight);
      simulation1.appendChild(renderer1.domElement);
      renderer1.setClearColor(0xf0f0f0);

      const geometry = new THREE.BoxGeometry();
      const material = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
      cube1 = new THREE.Mesh(geometry, material);
      scene1.add(cube1);

      const ambientLight = new THREE.AmbientLight(0x404040);
      scene1.add(ambientLight);
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
      directionalLight.position.set(1, 1, 1).normalize();
      scene1.add(directionalLight);

      camera1.position.z = 5;
      animate1();
    }

    function animate1() {
      requestAnimationFrame(animate1);
      cube1.position.x += velocity1;
      renderer1.render(scene1, camera1);
    }

    function applyForce1() {
      velocity1 += acceleration1;
    }

    function resetSimulation1() {
      velocity1 = 0;
      cube1.position.set(0, 0, 0);
    }

    // --- Simulation 2: Second Law (F=ma) ---
    let scene2, camera2, renderer2, cube2, forceLevel2 = 0, mass2 = 1;
    const baseAcceleration2 = 0.005;

    function initScene2() {
      scene2 = new THREE.Scene();
      camera2 = new THREE.PerspectiveCamera(75, simulation2.offsetWidth / simulation2.offsetHeight, 0.1, 1000);
      renderer2 = new THREE.WebGLRenderer({ antialias: true });
      renderer2.setSize(simulation2.offsetWidth, simulation2.offsetHeight);
      simulation2.appendChild(renderer2.domElement);
      renderer2.setClearColor(0xf0f0f0);

      const geometry = new THREE.BoxGeometry();
      const material = new THREE.MeshStandardMaterial({ color: 0xff0000 });
      cube2 = new THREE.Mesh(geometry, material);
      scene2.add(cube2);

      const ambientLight = new THREE.AmbientLight(0x404040);
      scene2.add(ambientLight);
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
      directionalLight.position.set(1, 1, 1).normalize();
      scene2.add(directionalLight);

      camera2.position.z = 5;
      animate2();
    }

    function animate2() {
      requestAnimationFrame(animate2);
      if (forceLevel2 > 0) {
        cube2.position.x += baseAcceleration2 * forceLevel2 / mass2;
      }
      renderer2.render(scene2, camera2);
    }

    function applyForce2(level) {
      forceLevel2 = level;
    }

    function changeMass2() {
      mass2 = mass2 === 1 ? 3 : 1;
      alert("Mass changed to " + mass2 + " units (visual demonstration). Observe acceleration with same force.");
      resetSimulation2();
    }

    function resetSimulation2() {
      forceLevel2 = 0;
      cube2.position.set(0, 0, 0);
    }

    // --- Simulation 3: Third Law (Action-Reaction) - Elastic Collision with Spheres ---
    let scene3, camera3, renderer3, sphere3_1, sphere3_2, force3Active = false, collisionDetected = false;
    let velocity3_1 = 0, velocity3_2 = 0;
    const initialDistance = 2;  // Center-to-center distance at start
    const sphereRadius = 0.5;
    let collisionTimer;

    function initScene3() {
      scene3 = new THREE.Scene();
      camera3 = new THREE.PerspectiveCamera(75, simulation3.offsetWidth / simulation3.offsetHeight, 0.1, 1000);
      renderer3 = new THREE.WebGLRenderer({ antialias: true });
      renderer3.setSize(simulation3.offsetWidth, simulation3.offsetHeight);
      simulation3.appendChild(renderer3.domElement);
      renderer3.setClearColor(0xf0f0f0);

      // Create sphere geometry and materials
      const widthSegments = 32, heightSegments = 32;
      const geometry = new THREE.SphereGeometry(sphereRadius, widthSegments, heightSegments);
      const material1 = new THREE.MeshStandardMaterial({ color: 0x1e90ff }); // DodgerBlue
      const material2 = new THREE.MeshStandardMaterial({ color: 0xffa500 }); // Orange

      sphere3_1 = new THREE.Mesh(geometry, material1);
      sphere3_2 = new THREE.Mesh(geometry, material2);

      // Set starting positions along the x-axis
      sphere3_1.position.x = -initialDistance / 2;
      sphere3_2.position.x = initialDistance / 2;

      scene3.add(sphere3_1);
      scene3.add(sphere3_2);

      const ambientLight = new THREE.AmbientLight(0x404040);
      scene3.add(ambientLight);
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
      directionalLight.position.set(1, 1, 1).normalize();
      scene3.add(directionalLight);

      camera3.position.z = 5;
      animate3();
    }

    function animate3() {
      requestAnimationFrame(animate3);

      // Update positions along the x-axis
      sphere3_1.position.x += velocity3_1;
      sphere3_2.position.x += velocity3_2;

      // Check for collision (when the distance between centers is less than or equal to the sum of radii)
      if (force3Active && !collisionDetected) {
        if (sphere3_2.position.x - sphere3_1.position.x <= sphereRadius * 2) {
          collisionDetected = true;
          force3Active = false;

          // For equal masses in a 1D elastic collision, simply swap velocities.
          let temp = velocity3_1;
          velocity3_1 = velocity3_2;
          velocity3_2 = temp;

          // Change both sphere colors to red on collision
          sphere3_1.material.color.setHex(0xff0000);
          sphere3_2.material.color.setHex(0xff0000);

          clearTimeout(collisionTimer);
          collisionTimer = setTimeout(() => {
            // Revert to original colors
            sphere3_1.material.color.setHex(0x1e90ff);
            sphere3_2.material.color.setHex(0xffa500);
            collisionDetected = false;
          }, 500);
        }
      }

      renderer3.render(scene3, camera3);
    }

    function applyForce3() {
      if (!force3Active && !collisionDetected) {
        force3Active = true;
        // Initiate spheres with velocities towards each other
        velocity3_1 = 0.015;
        velocity3_2 = -0.015;
      }
    }

    function resetSimulation3() {
      force3Active = false;
      collisionDetected = false;
      velocity3_1 = 0;
      velocity3_2 = 0;
      sphere3_1.position.set(-initialDistance / 2, 0, 0);
      sphere3_2.position.set(initialDistance / 2, 0, 0);
      sphere3_1.material.color.setHex(0x1e90ff);
      sphere3_2.material.color.setHex(0xffa500);
      clearTimeout(collisionTimer);
    }

    // Initialize simulations
    document.addEventListener('DOMContentLoaded', () => {
      const simulation1 = document.getElementById('simulation1');
      const simulation2 = document.getElementById('simulation2');
      const simulation3 = document.getElementById('simulation3');

      if (simulation1) initScene1();
      if (simulation2) initScene2();
      if (simulation3) initScene3();
    });

    // Handle window resize
    function onWindowResize() {
      if (camera1 && renderer1 && simulation1) {
        camera1.aspect = simulation1.offsetWidth / simulation1.offsetHeight;
        camera1.updateProjectionMatrix();
        renderer1.setSize(simulation1.offsetWidth, simulation1.offsetHeight);
      }
      if (camera2 && renderer2 && simulation2) {
        camera2.aspect = simulation2.offsetWidth / simulation2.offsetHeight;
        camera2.updateProjectionMatrix();
        renderer2.setSize(simulation2.offsetWidth, simulation2.offsetHeight);
      }
      if (camera3 && renderer3 && simulation3) {
        camera3.aspect = simulation3.offsetWidth / simulation3.offsetHeight;
        camera3.updateProjectionMatrix();
        renderer3.setSize(simulation3.offsetWidth, simulation3.offsetHeight);
      }
    }

    window.addEventListener('resize', onWindowResize, false);
  </script>
</body>
</html>
